#ifndef INSTRUCTION_TYPE_H
#define INSTRUCTION_TYPE_H
enum instruction_type_enum {

    assignment_ins=11,  //  11  =
    mul1_assignment_ins, // 12 *=
    mul2_assignment_ins, // 13 /=
    mul3_assignment_ins, // 14 %=
    add1_assignment_ins, // 15 +=
    add2_assignment_ins, // 16 -=
    shift1_assignment_ins, //17 <<=
    shift2_assignment_ins, //18 >>=
    and_assignment_ins,          //19 &
    exclusive_or_assignment_ins, //20 ^
    inclusive_or_assignment_ins, //21 |
    inc_op_unary_ins, //22 ++data
    dec_op_unary_ins, //23 --data
    ta_op_unary_ins, //24 &data  take address
    rta_op_unary_ins, //25 *data
    positive_unary_ins, //26 +data
    negative_unary_ins, //27 -data
    bit_reverse_unary_ins, //28 ~data
    negation_unary_ins, //29 !data
    sizeof_unary_ins, //30 sizeof unary_expression
    sizeof_type_ins,  //31 sizeof (type_name)
    alignof_type_ins, //32 alignof(type_name)

    bracket_postfix_ins, //33 postfix_expression[]
    parentheses_postfix_ins, //34 postfix_expression()

};


#endif







